#include<iostream>

using namespace std;

// void inc1(int x),inc2(int * p),inc3(int &y);

// 值传递不修改实参的值
// 主函数调用时给形参分配存储单元，把实参的值传递给形参，在调用结束后，形参的存储单元被释放，
// 而形参值的任何变化都不会影响到实参的值，实参的存储单元仍保留并维持数值不变
void inc1(int x)
{
    x++;    
    cout<<"x= "<<x<<endl;
}

// 地址传递使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，
// 而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。

// 地址传递的特点是形参并不存在存储空间，编译系统不为形参数组分配内存。数组名或指针就是一组连续空间的首地址。
// 因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，
// 形参的变化也就是实参的变化。

void inc2(int *p)
{
    (*p)++;
}

// 引用传递：

// 形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈

// 中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过

// 栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
void inc3(int &y)
{
    y++;
}

int main()
{
    int a=1,b=1,c=1;
    cout<<"a="<<a<<"b="<<b<<"c="<<c<<endl;

    inc1(a);inc2(&b);inc3(c);
    cout<<"a="<<a<<"b="<<b<<"c="<<c<<endl;

    return 0;
}    


